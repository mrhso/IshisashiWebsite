<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>等差分纬线多圆锥投影（伪）</title>
    </head>
    <body>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://unpkg.com/topojson@3"></script>
        <script src="https://d3js.org/d3-geo-projection.v4.min.js"></script>
        <script src="https://unpkg.com/d3-geo-polygon@1"></script>
        <form onsubmit="return false">
            <ul>
                <li><label>Width</label> <input type="number" id="width" value="954"></li>
                <li><label>Height</label> <input type="number" id="height" value="600"></li>
                <li><label>Projection</label> <textarea id="projection" rows="10" cols="100"></textarea></li>
                <li><label>Preset</label> <select id="preset">
                    <option value="original">等差分纬线多圆锥投影（1963 年方案）</option>
                    <option value="tan">正切差分纬线多圆锥投影（1976 年方案）</option>
                    <option value="sin">正弦差分纬线多圆锥投影（1979 年方案）</option>
                    <option value="east">系列世界地图（东半球）</option>
                    <option value="west">系列世界地图（西半球）</option>
                    <option value="north">系列世界地图（北半球）</option>
                    <option value="south">系列世界地图（南半球）</option>
                </select></li>
                <li><label>Precision</label> <input type="number" id="precision" value="0.7071067811865476" step="any"></li>
            </ul>
            <button onclick="return reload() && false">Reload</button>
        </form>
        <script>
            'use strict';

            let svg = d3.select('body').append('svg');
            let outline = { type: 'Sphere' };
            let graticule = d3.geoGraticule10();
            let land;

            // 修正曲线定向
            // https://observablehq.com/@fil/rewind
            const rewind = (() => {
                const geoRewindFeature = (feature, simple) =>
                    geoProjectSimple(feature, geoRewindStream(simple));
                const geoRewindProjection = (projection, simple) => {
                    const { stream: normalize } = geoRewindStream(simple);
                    return { stream: (s) => normalize(projection.stream(s)) };
                };
                function geoRewindStream(simple = true) {
                    const { geoContains, geoArea } = d3;

                    let ring, polygon;
                    return d3.geoTransform({
                        polygonStart() {
                            this.stream.polygonStart();
                            polygon = [];
                        },
                        lineStart() {
                            if (polygon) polygon.push((ring = []));
                            else this.stream.lineStart();
                        },
                        lineEnd() {
                            if (!polygon) this.stream.lineEnd();
                        },
                        point(x, y) {
                            if (polygon) ring.push([x, y]);
                            else this.stream.point(x, y);
                        },
                        polygonEnd() {
                            for (let [i, ring] of polygon.entries()) {
                                ring.push(ring[0].slice());
                                if (
                                    i
                                        ? // a hole must contain the first point of the polygon
                                            !geoContains(
                                                { type: 'Polygon', coordinates: [ring] },
                                                polygon[0][0]
                                            )
                                        : polygon[1]
                                        ? // the outer ring must contain the first point of its first hole (if any)
                                            !geoContains(
                                                { type: 'Polygon', coordinates: [ring] },
                                                polygon[1][0]
                                            )
                                        : // a single ring polygon must be smaller than a hemisphere (optional)
                                            simple &&
                                            geoArea({ type: 'Polygon', coordinates: [ring] }) > 2 * Math.PI
                                ) {
                                    ring.reverse();
                                };

                                this.stream.lineStart();
                                ring.pop();
                                for (const [x, y] of ring) this.stream.point(x, y);
                                this.stream.lineEnd();
                            };
                            this.stream.polygonEnd();
                            polygon = null;
                        }
                    });
                };
                const geoProjectSimple = (() => {
                    const { geoStream } = d3;

                    function projectFeatureCollection(o, stream) {
                        return { ...o, features: o.features.map((f) => projectFeature(f, stream)) };
                    };

                    function projectFeature(o, stream) {
                        return { ...o, geometry: projectGeometry(o.geometry, stream) };
                    };

                    function projectGeometryCollection(o, stream) {
                        return {
                            ...o,
                            geometries: o.geometries.map((o) => projectGeometry(o, stream))
                        };
                    };

                    function projectGeometry(o, stream) {
                        return !o
                            ? null
                            : o.type === 'GeometryCollection'
                            ? projectGeometryCollection(o, stream)
                            : o.type === 'Polygon' || o.type === 'MultiPolygon'
                            ? projectPolygons(o, stream)
                            : o;
                    };

                    function projectPolygons(o, stream) {
                        let coordinates = [];
                        let polygon, line;
                        geoStream(
                            o,
                            stream({
                                polygonStart() {
                                    coordinates.push((polygon = []));
                                },
                                polygonEnd() {},
                                lineStart() {
                                    polygon.push((line = []));
                                },
                                lineEnd() {
                                    line.push(line[0].slice());
                                },
                                point(x, y) {
                                    line.push([x, y]);
                                }
                            })
                        );
                        if (o.type === 'Polygon') coordinates = coordinates[0];
                        return { ...o, coordinates, rewind: true };
                    };

                    return function (object, projection) {
                        const stream = projection.stream;
                        let project;
                        if (!stream) throw new Error('invalid projection');
                        switch (object && object.type) {
                            case 'Feature':
                                project = projectFeature;
                                break;
                            case 'FeatureCollection':
                                project = projectFeatureCollection;
                                break;
                            default:
                                project = projectGeometry;
                                break;
                        };
                        return project(object, stream);
                    };
                })();
                // a simple duck test for projections and GeoJSON
                return function rewind(duck, simple) {
                    return duck?.stream
                        ? geoRewindProjection(duck, simple)
                        : duck?.type
                        ? geoRewindFeature(duck, simple)
                        : Array.isArray(duck)
                        ? Array.from(duck, (d) => rewind(d, simple))
                        : duck;
                };
            })();

            // 多边形，但是在圆柱投影下
            // https://observablehq.com/@fil/wgs84-resampling
            const resample = (() => {
                // by Mike Bostock -- https://github.com/d3/d3-geo-projection/issues/75
                // Takes a sparse line string that assumes Cartesian interpolation in spherical
                // coordinates and inserts interstitial points for greater accuracy when
                // rendering with D3, which assumes spherical interpolation.
                function resamplecoordinates(coordinates) {
                    var i = 0,
                            j = -1,
                            n = coordinates.length,
                            source = coordinates.slice(),
                            p0, x0, y0,
                            p1 = coordinates[0], x1 = p1[0], y1 = p1[1],
                            dx, dy, d2,
                            m2 = 10; // squared minimum angular distance
                    while (++i < n) {
                        p0 = p1, x0 = x1, y0 = y1;
                        p1 = source[i], x1 = p1[0], y1 = p1[1];
                        dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
                        coordinates[++j] = p0;
                        if (d2 > m2) for (var k = 1, m = Math.ceil(Math.sqrt(d2 / m2)); k < m; ++k) {
                            coordinates[++j] = [x0 + dx * k / m, y0 + dy * k / m];
                        };
                    };
                    coordinates[++j] = p1;
                    coordinates.length = j + 1;
                    return coordinates;
                };
                return function resample(obj) {
                    obj = JSON.parse(JSON.stringify(obj)); // deep clone urk
                    switch (obj.type) {
                        case 'FeatureCollection':
                            obj.features = obj.features.map(resample);
                            break;
                        case 'Feature':
                            obj.geometry = resample(obj.geometry);
                            break;
                        case 'MultiPolygon':
                            obj.coordinates = obj.coordinates.map(d => d.map(resamplecoordinates));
                            break;
                        case 'Polygon':
                            obj.coordinates = obj.coordinates.map(resamplecoordinates);
                            break;
                        case 'MultiLineString':
                            obj.coordinates = obj.coordinates.map(resamplecoordinates);
                            break;
                        case 'LineString':
                            obj.coordinates = resamplecoordinates(obj.coordinates);
                            break;
                    };
                    return obj;
                };
            })();

            const reload = () => {
                let projection = eval(document.getElementById('projection').value);
                let path = d3.geoPath(projection);
                svg.html(null);
                svg.attr('width', document.getElementById('width').value).attr('height', document.getElementById('height').value);
                let defs = svg.append('defs');
                projection.fitExtent([[0.5, 0.5], [svg.attr('width') - 0.5, svg.attr('height') - 0.5]], outline);
                projection.precision(document.getElementById('precision').value);
                defs.append('path').datum(outline).attr('id', 'outline').attr('d', path);
                defs.append('clipPath').attr('id', 'clip').append('use').attr('xlink:href', '#outline');
                svg.append('path').datum(graticule).attr('id', 'graticule').attr('d', path).attr('clip-path', 'url(#clip)').attr('stroke', '#808080').attr('fill', 'none');
                svg.append('path').datum(land).attr('id', 'land').attr('d', path).attr('clip-path', 'url(#clip)');
                svg.append('use').attr('xlink:href', '#outline').attr('stroke', '#000000').attr('fill', 'none');
            };

            let presets = {
                original: 'const ynSpline = (phi) => {\n    let sgn = Math.sign(phi);\n    let abs = Math.abs(phi);\n    if (abs < 0.17453292519943295) {\n        return 1.526210539991736 * phi - 0.9801332042527269 * phi ** 3;\n    } else if (abs < 0.26179938779914946) {\n        return -sgn * 0.028502674652705756 + 2.0161354287221007 * phi - sgn * 2.807062840266637 * phi ** 2 + 4.380961914923401 * phi ** 3;\n    } else if (abs < 0.3490658503988659) {\n        return sgn * 0.13463990722257307 + 0.14665914865790985 * phi + sgn * 4.333810542899712 * phi ** 2 - 4.711080460470761 * phi ** 3;\n    // 依方炳炎《不等分纬线多圆锥投影及其应用》所给正切差分纬线多圆锥投影表格推测黄赤交角取 23.439°\n    } else if (abs < 0.4090877233749509) {\n        return -sgn * 0.06639485330310924 + 1.8744256456896295 * phi - sgn * 0.6158758703012893 * phi ** 2 + 0.015521896023635911 * phi ** 3;\n    } else if (abs < 0.5235987755982989) {\n        return -sgn * 0.1468159430630838 + 2.4641848965650044 * phi - sgn * 2.057520821193225 * phi ** 2 + 1.1902047073274848 * phi ** 3;\n    } else if (abs < 0.6981317007977318) {\n        return sgn * 0.07721845577459269 + 1.1805623446500588 * phi + sgn * 0.3940176692247348 * phi ** 2 - 0.37049316839276086 * phi ** 3;\n    } else if (abs < 0.7853981633974483) {\n        return -sgn * 0.15888430664152556 + 2.1951392309868267 * phi - sgn * 1.059256670240791 * phi ** 2 + 0.32339421599088175 * phi ** 3;\n    } else if (abs < 0.8726646259971648) {\n        return sgn * 0.11034530000416219 + 1.1667578856024794 * phi + sgn * 0.2501191257705094 * phi ** 2 - 0.232322131476008 * phi ** 3;\n    } else if (abs < 1.0471975511965979) {\n        return -sgn * 0.2810538444727505 + 2.5122890306159738 * phi - sgn * 1.2917459904830582 * phi ** 2 + 0.3566269601225083 * phi ** 3;\n    } else if (abs < 1.1617086034199458) {\n        return sgn * 1.1898247338373382 - 1.701467705052568 * phi + sgn * 2.7320952903274462 * phi ** 2 - 0.9242014999939219 * phi ** 3;\n    } else if (abs < 1.2217304763960306) {\n        return sgn * 4.829178185005328 - 11.099745656478914 * phi + sgn * 10.822142935458784 * phi ** 2 - 3.2455087025388356 * phi ** 3;\n    } else if (abs < 1.3089969389957472) {\n        return -sgn * 5.4857137465302355 + 14.228816078258236 * phi - sgn * 9.909566900783982 * phi ** 2 + 2.4108697532067147 * phi ** 3;\n    } else if (abs < 1.3962634015954636) {\n        return -sgn * 1.7249614520211491 + 5.609806707477793 * phi - sgn * 3.325128760391627 * phi ** 2 + 0.734156349164714 * phi ** 3;\n    } else {\n        return -sgn * 1.0257143683273855 + 4.107410205009654 * phi - sgn * 2.2491165260586206 * phi ** 2 + 0.47727735028253476 * phi ** 3;\n    };\n};\nconst xnSpline = (phi) => {\n    let abs = Math.abs(phi);\n    if (abs < 0.17453292519943295) {\n        return 2.589813150474736 - 0.8811990464726521 * abs ** 2 + 0.19245572476303263 * abs ** 3;\n    } else if (abs < 0.26179938779914946) {\n        return 2.5876896069659323 + 0.03650102420006108 * abs - 1.0903345099294903 * abs ** 2 + 0.5918750381826755 * abs ** 3;\n    } else if (abs < 0.3490658503988659) {\n        return 2.602120380222071 - 0.12886345633734178 * abs - 0.4586887221850619 * abs ** 2 - 0.21236135703892384 * abs ** 3;\n    } else if (abs < 0.4090877233749509) {\n        return 2.495783615104118 + 0.7850337209125569 * abs - 3.076811280451987 * abs ** 2 + 2.2877615235725557 * abs ** 3;\n    } else if (abs < 0.5235987755982989) {\n        return 2.6748455625262038 - 0.5280974526032437 * abs + 0.1330899179573457 * abs ** 2 - 0.3277338946455117 * abs ** 3;\n    } else if (abs < 0.6981317007977318) {\n        return 2.599981307449484 - 0.09915686737455581 * abs - 0.6861262552251675 * abs ** 2 + 0.19379531904578096 * abs ** 3;\n    } else if (abs < 0.7853981633974483) {\n        return 2.800670691160745 - 0.9615559683548129 * abs + 0.5491694633259633 * abs ** 2 - 0.39601494031722057 * abs ** 3;\n    } else if (abs < 0.8726646259971648) {\n        return 3.114809804335404 - 2.1614789926808466 * abs + 2.076958908536082 * abs ** 2 - 1.0444289195407266 * abs ** 3;\n    } else if (abs < 1.0471975511965979) {\n        return 2.137821200907338 + 1.197160423847675 * abs - 1.7717583609312306 * abs ** 2 + 0.42567278765654926 * abs ** 3;\n    } else if (abs < 1.1617086034199458) {\n        return 2.2494471637212636 + 0.8773755961815649 * abs - 1.466386344638123 * abs ** 2 + 0.3284698559065754 * abs ** 3;\n    } else if (abs < 1.2217304763960306) {\n        return -0.7451922777991411 + 8.610742034299971 * abs - 8.123276390345113 * abs ** 2 + 2.238555863737288 * abs ** 3;\n    } else if (abs < 1.3089969389957472) {\n        return 1.0460095754207768 + 4.212386043777991 * abs - 4.523173032445226 * abs ** 2 + 1.2563143007918631 * abs ** 3;\n    } else if (abs < 1.3962634015954636) {\n        return 15.094850731887474 - 27.9851861688313 * abs + 20.073960278890883 * abs ** 2 - 5.007294263031275 * abs ** 3;\n    } else {\n        return -3.217198146731983 + 11.359930642999952 * abs - 8.104903943198517 * abs ** 2 + 1.7199140344600505 * abs ** 3;\n    };\n};\n// 吴忠性《地图投影》4-2-3\n// 胡毓钜《地图投影》12-4\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953537 * phi + 0.01476138 * phi ** 3;\n    let yn = ynSpline(phi);\n    let xn = xnSpline(phi);\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.62070986487959) {\n        y = Math.sign(y) * 1.62070986487959;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                tan: '// 胡毓钜《地图投影》12-5\n// 方炳炎《不等分纬线多圆锥投影及其应用》\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.10096477407538117;\n    let lambdaN = 3.6651914291880923;\n    // 加上符号以使上下对称\n    let y0 = phi + Math.sign(phi) * 0.06683225 * phi ** 4;\n    let yn = y0 + 0.20983796245430156 * phi;\n    let xn = Math.sqrt(6.057049067368377 - yn ** 2) + 0.43948344371692494;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.tan(Math.abs(lambda) / 5)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.tan(Math.abs(lambda) / 5)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.9776756220609721) {\n        y = Math.sign(y) * 1.9776756220609721;\n    };\n    return [x, y];\n}).rotate([-120, 0, 0]);',
                sin: '// 阎大昌《以 (x/a)^n+(y/b)^n=1 为边缘经线的多圆锥投影》\nd3.geoProjection((lambda, phi) => {\n    let b = 1.11523;\n    let C = 0.11930825303967894;\n    let lambdaN = Math.PI;\n    // 加上符号与绝对值以使上下对称\n    let y0 = 0.95 * phi + Math.sign(phi) * 0.048795271 * phi ** 4;\n    let yn = y0 + 0.194675814 * phi;\n    let xn = 1.24 * Math.cbrt(10.052210101483936 - Math.abs(yn) ** 3);\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.sin(Math.abs(lambda) / 3)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.sin(Math.abs(lambda) / 3)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.7893254476343903) {\n        y = Math.sign(y) * 1.7893254476343903;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                east: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                west: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n});',
                north: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n}).rotate([-150, -120, 90]);',
                south: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n}).rotate([105, 165, 90]).angle([90]);',
                // TODO
                // std: '',
            };

            document.getElementById('projection').value = presets.original;
            document.getElementById('preset').onchange = () => {
                document.getElementById('projection').value = presets[document.getElementById('preset').value];
                reload();
            };

            d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json').then((json) => {
                land = rewind(topojson.feature(json, json.objects.land));
                reload();
            });
        </script>
    </body>
</html>
