<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>等差分纬线多圆锥投影（伪）</title>
    </head>
    <body>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://unpkg.com/topojson@3"></script>
        <script src="https://d3js.org/d3-geo-projection.v4.min.js"></script>
        <script src="https://unpkg.com/d3-geo-polygon@1"></script>
        <form onsubmit="return false">
            <ul>
                <li><label>Width</label> <input type="number" id="width" value="954"></li>
                <li><label>Height</label> <input type="number" id="height" value="600"></li>
                <li><label>Projection</label> <textarea id="projection" rows="10" cols="100"></textarea></li>
                <li><label>Preset</label> <select id="preset">
                    <option value="original">等差分纬线多圆锥投影（1963 年方案）</option>
                    <option value="tan">正切差分纬线多圆锥投影（1976 年方案）</option>
                    <option value="sin">正弦差分纬线多圆锥投影（1979 年方案）</option>
                    <option value="east">系列世界地图（东半球）</option>
                    <option value="west">系列世界地图（西半球）</option>
                    <option value="north">系列世界地图（北半球）</option>
                    <option value="south">系列世界地图（南半球）</option>
                </select></li>
                <li><label>Precision</label> <input type="number" id="precision" value="0.7071067811865476" step="any"></li>
            </ul>
            <button onclick="return reload() && false">Reload</button>
        </form>
        <script>
            'use strict';

            let svg = d3.select('body').append('svg');
            let outline = { type: 'Sphere' };
            let graticule = d3.geoGraticule10();
            let land;

            // 修正曲线定向
            // https://observablehq.com/@fil/rewind
            const rewind = (() => {
                const geoRewindFeature = (feature, simple) =>
                    geoProjectSimple(feature, geoRewindStream(simple));
                const geoRewindProjection = (projection, simple) => {
                    const { stream: normalize } = geoRewindStream(simple);
                    return { stream: (s) => normalize(projection.stream(s)) };
                };
                function geoRewindStream(simple = true) {
                    const { geoContains, geoArea } = d3;

                    let ring, polygon;
                    return d3.geoTransform({
                        polygonStart() {
                            this.stream.polygonStart();
                            polygon = [];
                        },
                        lineStart() {
                            if (polygon) polygon.push((ring = []));
                            else this.stream.lineStart();
                        },
                        lineEnd() {
                            if (!polygon) this.stream.lineEnd();
                        },
                        point(x, y) {
                            if (polygon) ring.push([x, y]);
                            else this.stream.point(x, y);
                        },
                        polygonEnd() {
                            for (let [i, ring] of polygon.entries()) {
                                ring.push(ring[0].slice());
                                if (
                                    i
                                        ? // a hole must contain the first point of the polygon
                                            !geoContains(
                                                { type: 'Polygon', coordinates: [ring] },
                                                polygon[0][0]
                                            )
                                        : polygon[1]
                                        ? // the outer ring must contain the first point of its first hole (if any)
                                            !geoContains(
                                                { type: 'Polygon', coordinates: [ring] },
                                                polygon[1][0]
                                            )
                                        : // a single ring polygon must be smaller than a hemisphere (optional)
                                            simple &&
                                            geoArea({ type: 'Polygon', coordinates: [ring] }) > 2 * Math.PI
                                ) {
                                    ring.reverse();
                                };

                                this.stream.lineStart();
                                ring.pop();
                                for (const [x, y] of ring) this.stream.point(x, y);
                                this.stream.lineEnd();
                            };
                            this.stream.polygonEnd();
                            polygon = null;
                        }
                    });
                };
                const geoProjectSimple = (() => {
                    const { geoStream } = d3;

                    function projectFeatureCollection(o, stream) {
                        return { ...o, features: o.features.map((f) => projectFeature(f, stream)) };
                    };

                    function projectFeature(o, stream) {
                        return { ...o, geometry: projectGeometry(o.geometry, stream) };
                    };

                    function projectGeometryCollection(o, stream) {
                        return {
                            ...o,
                            geometries: o.geometries.map((o) => projectGeometry(o, stream))
                        };
                    };

                    function projectGeometry(o, stream) {
                        return !o
                            ? null
                            : o.type === 'GeometryCollection'
                            ? projectGeometryCollection(o, stream)
                            : o.type === 'Polygon' || o.type === 'MultiPolygon'
                            ? projectPolygons(o, stream)
                            : o;
                    };

                    function projectPolygons(o, stream) {
                        let coordinates = [];
                        let polygon, line;
                        geoStream(
                            o,
                            stream({
                                polygonStart() {
                                    coordinates.push((polygon = []));
                                },
                                polygonEnd() {},
                                lineStart() {
                                    polygon.push((line = []));
                                },
                                lineEnd() {
                                    line.push(line[0].slice());
                                },
                                point(x, y) {
                                    line.push([x, y]);
                                }
                            })
                        );
                        if (o.type === 'Polygon') coordinates = coordinates[0];
                        return { ...o, coordinates, rewind: true };
                    };

                    return function (object, projection) {
                        const stream = projection.stream;
                        let project;
                        if (!stream) throw new Error('invalid projection');
                        switch (object && object.type) {
                            case 'Feature':
                                project = projectFeature;
                                break;
                            case 'FeatureCollection':
                                project = projectFeatureCollection;
                                break;
                            default:
                                project = projectGeometry;
                                break;
                        };
                        return project(object, stream);
                    };
                })();
                // a simple duck test for projections and GeoJSON
                return function rewind(duck, simple) {
                    return duck?.stream
                        ? geoRewindProjection(duck, simple)
                        : duck?.type
                        ? geoRewindFeature(duck, simple)
                        : Array.isArray(duck)
                        ? Array.from(duck, (d) => rewind(d, simple))
                        : duck;
                };
            })();

            // 多边形，但是在圆柱投影下
            // https://observablehq.com/@fil/wgs84-resampling
            const resample = (() => {
                // by Mike Bostock -- https://github.com/d3/d3-geo-projection/issues/75
                // Takes a sparse line string that assumes Cartesian interpolation in spherical
                // coordinates and inserts interstitial points for greater accuracy when
                // rendering with D3, which assumes spherical interpolation.
                function resamplecoordinates(coordinates) {
                    var i = 0,
                            j = -1,
                            n = coordinates.length,
                            source = coordinates.slice(),
                            p0, x0, y0,
                            p1 = coordinates[0], x1 = p1[0], y1 = p1[1],
                            dx, dy, d2,
                            m2 = 10; // squared minimum angular distance
                    while (++i < n) {
                        p0 = p1, x0 = x1, y0 = y1;
                        p1 = source[i], x1 = p1[0], y1 = p1[1];
                        dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
                        coordinates[++j] = p0;
                        if (d2 > m2) for (var k = 1, m = Math.ceil(Math.sqrt(d2 / m2)); k < m; ++k) {
                            coordinates[++j] = [x0 + dx * k / m, y0 + dy * k / m];
                        };
                    };
                    coordinates[++j] = p1;
                    coordinates.length = j + 1;
                    return coordinates;
                };
                return function resample(obj) {
                    obj = JSON.parse(JSON.stringify(obj)); // deep clone urk
                    switch (obj.type) {
                        case 'FeatureCollection':
                            obj.features = obj.features.map(resample);
                            break;
                        case 'Feature':
                            obj.geometry = resample(obj.geometry);
                            break;
                        case 'MultiPolygon':
                            obj.coordinates = obj.coordinates.map(d => d.map(resamplecoordinates));
                            break;
                        case 'Polygon':
                            obj.coordinates = obj.coordinates.map(resamplecoordinates);
                            break;
                        case 'MultiLineString':
                            obj.coordinates = obj.coordinates.map(resamplecoordinates);
                            break;
                        case 'LineString':
                            obj.coordinates = resamplecoordinates(obj.coordinates);
                            break;
                    };
                    return obj;
                };
            })();

            const reload = () => {
                let projection = eval(document.getElementById('projection').value);
                let path = d3.geoPath(projection);
                svg.html(null);
                svg.attr('width', document.getElementById('width').value).attr('height', document.getElementById('height').value);
                let defs = svg.append('defs');
                projection.fitExtent([[0.5, 0.5], [svg.attr('width') - 0.5, svg.attr('height') - 0.5]], outline);
                projection.precision(document.getElementById('precision').value);
                defs.append('path').datum(outline).attr('id', 'outline').attr('d', path);
                defs.append('clipPath').attr('id', 'clip').append('use').attr('xlink:href', '#outline');
                svg.append('path').datum(graticule).attr('id', 'graticule').attr('d', path).attr('clip-path', 'url(#clip)').attr('stroke', '#808080').attr('fill', 'none');
                svg.append('path').datum(land).attr('id', 'land').attr('d', path).attr('clip-path', 'url(#clip)');
                svg.append('use').attr('xlink:href', '#outline').attr('stroke', '#000000').attr('fill', 'none');
            };

            let presets = {
                original: 'const ynSpline = (phi) => {\n    let sgn = Math.sign(phi);\n    let abs = Math.abs(phi);\n    if (abs < 0.17453292519943295) {\n        return 1.5271229924920866 * phi - 1.0100872528750704 * phi ** 3;\n    } else if (abs < 0.26179938779914946) {\n        return -sgn * 0.030891469712581106 + 2.0581082437382188 * phi - sgn * 3.0423213880097015 * phi ** 2 + 4.80031859563621 * phi ** 3;\n    } else if (abs < 0.3490658503988659) {\n        return sgn * 0.1709495921326784 - 0.25481995149626163 * phi + sgn * 5.792413538906713 * phi ** 2 - 6.448415280566685 * phi ** 3;\n    // 从胡毓钜《地图投影》给出的纬圈半径反推黄赤交角取 23.5°\n    // 如果胡毓钜有原始直角坐标表的话，应该可以直接查取表中的 Δλ=0° 与 Δλ=180° 计算，没必要自行算出中央经线上的纵坐标——这样说来，原始数据似乎就是 23.5°？\n    } else if (abs < 0.41015237421866746) {\n        return -sgn * 0.28946654896159746 + 3.702165304164013 * phi - sgn * 5.543514198334726 * phi ** 2 + 4.376598322920309 * phi ** 3;\n    } else if (abs < 0.5235987755982989) {\n        return sgn * 0.05307970360138684 + 1.1966604667323502 * phi + sgn * 0.5652029393012619 * phi ** 2 - 0.5879933114879028 * phi ** 3;\n    } else if (abs < 0.6981317007977318) {\n        return -sgn * 0.040699882295465985 + 1.7339779143697747 * phi - sgn * 0.4609977943109389 * phi ** 2 + 0.06530636594774145 * phi ** 3;\n    } else if (abs < 0.7853981633974483) {\n        return -sgn * 0.04647955512903578 + 1.758814228894522 * phi - sgn * 0.49657319433412633 * phi ** 2 + 0.08229236824622688 * phi ** 3;\n    } else if (abs < 0.8726646259971648) {\n        return sgn * 0.1627992073626043 + 0.95942824006174 * phi + sgn * 0.5212366581549931 * phi ** 2 - 0.3496795494905096 * phi ** 3;\n    } else if (abs < 1.0471975511965979) {\n        return -sgn * 0.4934162518439651 + 3.21533081588828 * phi - sgn * 2.063837273596045 * phi ** 2 + 0.637745957300319 * phi ** 3;\n    } else if (abs < 1.160643952576229) {\n        return sgn * 2.6323996710067004 - 5.739472179818403 * phi + sgn * 6.487369693488941 * phi ** 2 - 2.0841877591265408 * phi ** 3;\n    } else if (abs < 1.2217304763960306) {\n        return -sgn * 0.06331771971040438 + 1.228342673479739 * phi + sgn * 0.4839654299919428 * phi ** 2 - 0.36002872649885964 * phi ** 3;\n    } else if (abs < 1.3089969389957472) {\n        return -sgn * 3.0290030290957928 + 8.510682027411134 * phi - sgn * 5.4767104266122795 * phi ** 2 + 1.2662644622104196 * phi ** 3;\n    } else if (abs < 1.3962634015954636) {\n        return -sgn * 2.455207302687121 + 7.195639090376726 * phi - sgn * 4.472091624338152 * phi ** 2 + 1.0104403849224404 * phi ** 3;\n    } else {\n        return -sgn * 0.9501716941205609 + 3.9619320258354533 * phi - sgn * 2.156119537089983 * phi ** 2 + 0.45754277629984 * phi ** 3;\n    };\n};\nconst xnSpline = (phi) => {\n    let abs = Math.abs(phi);\n    if (abs < 0.17453292519943295) {\n        return 2.589813150474736 - 0.8852514776808 * abs ** 2 + 0.2156744452624301 * abs ** 3;\n    } else if (abs < 0.26179938779914946) {\n        return 2.5888006039905727 + 0.01740439203101801 * abs - 0.9849712985176455 * abs ** 2 + 0.4061252741874958 * abs ** 3;\n    } else if (abs < 0.3490658503988659) {\n        return 2.586566421877108 + 0.043006233184045874 * abs - 1.082763128239835 * abs ** 2 + 0.5306376989417948 * abs ** 3;\n    } else if (abs < 0.41015237421866746) {\n        return 2.591710444836326 - 0.0012033876081931026 * abs - 0.9561118939763797 * abs ** 2 + 0.4096946790514837 * abs ** 3;\n    } else if (abs < 0.5235987755982989) {\n        return 2.59129428902019 + 0.0018405236962004488 * abs - 0.9635333097616526 * abs ** 2 + 0.41572610887429085 * abs ** 3;\n    } else if (abs < 0.6981317007977318) {\n        return 2.6488583874553955 - 0.3279774654850895 * abs - 0.333627350175674 * abs ** 2 + 0.014715520269682264 * abs ** 3;\n    } else if (abs < 0.7853981633974483) {\n        return 2.7684001717397826 - 0.8416704441069918 * abs + 0.40218364083780167 * abs ** 2 - 0.33660834893374025 * abs ** 3;\n    } else if (abs < 0.8726646259971648) {\n        return 3.0046791444742453 - 1.74418963913175 * abs + 1.5513067698258702 * abs ** 2 - 0.8243113521328783 * abs ** 3;\n    } else if (abs < 1.0471975511965979) {\n        return 2.4264910216094973 + 0.24347471315274363 * abs - 0.7263887996642484 * abs ** 2 + 0.04570426884999046 * abs ** 3;\n    } else if (abs < 1.160643952576229) {\n        return 0.32726032286130863 + 6.257327676281242 * abs - 6.469195356322702 * abs ** 2 + 1.8736963702754696 * abs ** 3;\n    } else if (abs < 1.2217304763960306) {\n        return 5.713126712541212 - 7.663909007178327 * abs + 5.525212276232679 * abs ** 2 - 1.5710601966665094 * abs ** 3;\n    } else if (abs < 1.3089969389957472) {\n        return -2.20484561744157 + 11.778936570366538 * abs - 10.388973342594724 * abs ** 2 + 2.77091918593635 * abs ** 3;\n    } else if (abs < 1.3962634015954636) {\n        return 16.061152339503188 - 30.08364709073422 * abs + 21.59168483466383 * abs ** 2 - 5.3728885456523585 * abs ** 3;\n    } else {\n        return -3.317160382002574 + 11.55243539777649 * abs - 8.22796269096389 * abs ** 2 + 1.7460279117901278 * abs ** 3;\n    };\n};\n// 吴忠性《地图投影》4-2-3\n// 胡毓钜《地图投影》12-4\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953537 * phi + 0.01476138 * phi ** 3;\n    let yn = ynSpline(phi);\n    let xn = xnSpline(phi);\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.62070986487959) {\n        y = Math.sign(y) * 1.62070986487959;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                tan: '// 胡毓钜《地图投影》12-5\n// 方炳炎《不等分纬线多圆锥投影及其应用》\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.10096477407538117;\n    let lambdaN = 3.6651914291880923;\n    // 加上符号以使上下对称\n    let y0 = phi + Math.sign(phi) * 0.06683225 * phi ** 4;\n    let yn = y0 + 0.20983796245430156 * phi;\n    let xn = Math.sqrt(6.057049067368377 - yn ** 2) + 0.43948344371692494;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.tan(Math.abs(lambda) / 5)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.tan(Math.abs(lambda) / 5)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.9776756220609721) {\n        y = Math.sign(y) * 1.9776756220609721;\n    };\n    return [x, y];\n}).rotate([-120, 0, 0]);',
                sin: '// 阎大昌《以 (x/a)^n+(y/b)^n=1 为边缘经线的多圆锥投影》\nd3.geoProjection((lambda, phi) => {\n    let b = 1.11523;\n    let C = 0.11930825303967894;\n    let lambdaN = Math.PI;\n    // 加上符号与绝对值以使上下对称\n    let y0 = 0.95 * phi + Math.sign(phi) * 0.048795271 * phi ** 4;\n    let yn = y0 + 0.194675814 * phi;\n    let xn = 1.24 * Math.cbrt(10.052210101483936 - Math.abs(yn) ** 3);\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.sin(Math.abs(lambda) / 3)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.sin(Math.abs(lambda) / 3)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.7893254476343903) {\n        y = Math.sign(y) * 1.7893254476343903;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                east: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                west: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n});',
                north: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n}).rotate([-150, -120, 90]);',
                south: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n}).rotate([105, 165, 90]).angle([90]);',
                // TODO
                // std: '',
            };

            document.getElementById('projection').value = presets.original;
            document.getElementById('preset').onchange = () => {
                document.getElementById('projection').value = presets[document.getElementById('preset').value];
                reload();
            };

            d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json').then((json) => {
                land = rewind(topojson.feature(json, json.objects.land));
                reload();
            });
        </script>
    </body>
</html>
