<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>等差分纬线多圆锥投影（伪）</title>
    </head>
    <body>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://unpkg.com/topojson@3"></script>
        <script src="https://d3js.org/d3-geo-projection.v4.min.js"></script>
        <script src="https://unpkg.com/d3-geo-polygon@1"></script>
        <form onsubmit="return false">
            <ul>
                <li><label>Width</label> <input type="number" id="width" value="954"></li>
                <li><label>Height</label> <input type="number" id="height" value="600"></li>
                <li><label>Projection</label> <textarea id="projection" rows="10" cols="100"></textarea></li>
                <li><label>Preset</label> <select id="preset">
                    <option value="original">等差分纬线多圆锥投影（1963 年方案）</option>
                    <option value="tan">正切差分纬线多圆锥投影（1976 年方案）</option>
                    <option value="sin">正弦差分纬线多圆锥投影（1979 年方案）</option>
                    <option value="east">系列世界地图（东半球）</option>
                    <option value="west">系列世界地图（西半球）</option>
                    <option value="north">系列世界地图（北半球）</option>
                    <option value="south">系列世界地图（南半球）</option>
                </select></li>
                <li><label>Precision</label> <input type="number" id="precision" value="0.7071067811865476" step="any"></li>
            </ul>
            <button onclick="return reload() && false">Reload</button>
        </form>
        <script>
            'use strict';

            let svg = d3.select('body').append('svg');
            let outline = { type: 'Sphere' };
            let graticule = d3.geoGraticule10();
            let world;

            // 修正曲线定向
            // https://observablehq.com/@fil/rewind
            const rewind = (() => {
                const geoRewindFeature = (feature, simple) =>
                    geoProjectSimple(feature, geoRewindStream(simple));
                const geoRewindProjection = (projection, simple) => {
                    const { stream: normalize } = geoRewindStream(simple);
                    return { stream: (s) => normalize(projection.stream(s)) };
                };
                function geoRewindStream(simple = true) {
                    const { geoContains, geoArea } = d3;

                    let ring, polygon;
                    return d3.geoTransform({
                        polygonStart() {
                            this.stream.polygonStart();
                            polygon = [];
                        },
                        lineStart() {
                            if (polygon) polygon.push((ring = []));
                            else this.stream.lineStart();
                        },
                        lineEnd() {
                            if (!polygon) this.stream.lineEnd();
                        },
                        point(x, y) {
                            if (polygon) ring.push([x, y]);
                            else this.stream.point(x, y);
                        },
                        polygonEnd() {
                            for (let [i, ring] of polygon.entries()) {
                                ring.push(ring[0].slice());
                                if (
                                    i
                                        ? // a hole must contain the first point of the polygon
                                            !geoContains(
                                                { type: 'Polygon', coordinates: [ring] },
                                                polygon[0][0]
                                            )
                                        : polygon[1]
                                        ? // the outer ring must contain the first point of its first hole (if any)
                                            !geoContains(
                                                { type: 'Polygon', coordinates: [ring] },
                                                polygon[1][0]
                                            )
                                        : // a single ring polygon must be smaller than a hemisphere (optional)
                                            simple &&
                                            geoArea({ type: 'Polygon', coordinates: [ring] }) > 2 * Math.PI
                                ) {
                                    ring.reverse();
                                };

                                this.stream.lineStart();
                                ring.pop();
                                for (const [x, y] of ring) this.stream.point(x, y);
                                this.stream.lineEnd();
                            };
                            this.stream.polygonEnd();
                            polygon = null;
                        }
                    });
                };
                const geoProjectSimple = (() => {
                    const { geoStream } = d3;

                    function projectFeatureCollection(o, stream) {
                        return { ...o, features: o.features.map((f) => projectFeature(f, stream)) };
                    };

                    function projectFeature(o, stream) {
                        return { ...o, geometry: projectGeometry(o.geometry, stream) };
                    };

                    function projectGeometryCollection(o, stream) {
                        return {
                            ...o,
                            geometries: o.geometries.map((o) => projectGeometry(o, stream))
                        };
                    };

                    function projectGeometry(o, stream) {
                        return !o
                            ? null
                            : o.type === 'GeometryCollection'
                            ? projectGeometryCollection(o, stream)
                            : o.type === 'Polygon' || o.type === 'MultiPolygon'
                            ? projectPolygons(o, stream)
                            : o;
                    };

                    function projectPolygons(o, stream) {
                        let coordinates = [];
                        let polygon, line;
                        geoStream(
                            o,
                            stream({
                                polygonStart() {
                                    coordinates.push((polygon = []));
                                },
                                polygonEnd() {},
                                lineStart() {
                                    polygon.push((line = []));
                                },
                                lineEnd() {
                                    line.push(line[0].slice());
                                },
                                point(x, y) {
                                    line.push([x, y]);
                                }
                            })
                        );
                        if (o.type === 'Polygon') coordinates = coordinates[0];
                        return { ...o, coordinates, rewind: true };
                    };

                    return function (object, projection) {
                        const stream = projection.stream;
                        let project;
                        if (!stream) throw new Error('invalid projection');
                        switch (object && object.type) {
                            case 'Feature':
                                project = projectFeature;
                                break;
                            case 'FeatureCollection':
                                project = projectFeatureCollection;
                                break;
                            default:
                                project = projectGeometry;
                                break;
                        };
                        return project(object, stream);
                    };
                })();
                // a simple duck test for projections and GeoJSON
                return function rewind(duck, simple) {
                    return duck?.stream
                        ? geoRewindProjection(duck, simple)
                        : duck?.type
                        ? geoRewindFeature(duck, simple)
                        : Array.isArray(duck)
                        ? Array.from(duck, (d) => rewind(d, simple))
                        : duck;
                };
            })();

            // 多边形，但是在圆柱投影下
            // https://observablehq.com/@fil/wgs84-resampling
            const resample = (() => {
                // by Mike Bostock -- https://github.com/d3/d3-geo-projection/issues/75
                // Takes a sparse line string that assumes Cartesian interpolation in spherical
                // coordinates and inserts interstitial points for greater accuracy when
                // rendering with D3, which assumes spherical interpolation.
                function resamplecoordinates(coordinates) {
                    var i = 0,
                            j = -1,
                            n = coordinates.length,
                            source = coordinates.slice(),
                            p0, x0, y0,
                            p1 = coordinates[0], x1 = p1[0], y1 = p1[1],
                            dx, dy, d2,
                            m2 = 10; // squared minimum angular distance
                    while (++i < n) {
                        p0 = p1, x0 = x1, y0 = y1;
                        p1 = source[i], x1 = p1[0], y1 = p1[1];
                        dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
                        coordinates[++j] = p0;
                        if (d2 > m2) for (var k = 1, m = Math.ceil(Math.sqrt(d2 / m2)); k < m; ++k) {
                            coordinates[++j] = [x0 + dx * k / m, y0 + dy * k / m];
                        };
                    };
                    coordinates[++j] = p1;
                    coordinates.length = j + 1;
                    return coordinates;
                };
                return function resample(obj) {
                    obj = JSON.parse(JSON.stringify(obj)); // deep clone urk
                    switch (obj.type) {
                        case 'FeatureCollection':
                            obj.features = obj.features.map(resample);
                            break;
                        case 'Feature':
                            obj.geometry = resample(obj.geometry);
                            break;
                        case 'MultiPolygon':
                            obj.coordinates = obj.coordinates.map(d => d.map(resamplecoordinates));
                            break;
                        case 'Polygon':
                            obj.coordinates = obj.coordinates.map(resamplecoordinates);
                            break;
                        case 'MultiLineString':
                            obj.coordinates = obj.coordinates.map(resamplecoordinates);
                            break;
                        case 'LineString':
                            obj.coordinates = resamplecoordinates(obj.coordinates);
                            break;
                    };
                    return obj;
                };
            })();

            const reload = () => {
                let projection = eval(document.getElementById('projection').value);
                let path = d3.geoPath(projection);
                svg.html(null);
                svg.attr('width', document.getElementById('width').value).attr('height', document.getElementById('height').value);
                let defs = svg.append('defs');
                projection.fitExtent([[0.5, 0.5], [svg.attr('width') - 0.5, svg.attr('height') - 0.5]], outline);
                projection.precision(document.getElementById('precision').value);
                defs.append('path').datum(outline).attr('id', 'outline').attr('d', path);
                defs.append('clipPath').attr('id', 'clip').append('use').attr('xlink:href', '#outline');
                svg.append('path').datum(graticule).attr('id', 'graticule').attr('d', path).attr('clip-path', 'url(#clip)').attr('stroke', '#808080').attr('fill', 'none');
                svg.append('path').datum(rewind(topojson.feature(world, world.objects.land))).attr('id', 'land').attr('d', path).attr('clip-path', 'url(#clip)');
                svg.append('use').attr('xlink:href', '#outline').attr('stroke', '#000000').attr('fill', 'none');
            };

            let presets = {
                original: 'const ynSpline = (phi) => {\n    let sgn = Math.sign(phi);\n    let abs = Math.abs(phi);\n    if (abs < 0.17453292519943295) {\n        return 1.5262105400674268 * phi - 0.9801332067375023 * phi ** 3;\n    } else if (0.17453292519943295 <= abs && abs < 0.26179938779914946) {\n        return -sgn * 0.028502674850863254 + 2.016135432203868 * phi - sgn * 2.8070628597820173 * phi ** 2 + 4.380961949710257 * phi ** 3;\n    } else if (0.26179938779914946 <= abs && abs < 0.3490658503988659) {\n        return sgn * 0.13463991023456703 + 0.1466591153540509 * phi + sgn * 4.333810663895072 * phi ** 2 - 4.711080604587737 * phi ** 3;\n    // 依方炳炎《不等分纬线多圆锥投影及其应用》所给正切差分纬线多圆锥投影表格推测黄赤交角取 23.439°\n    } else if (0.3490658503988659 <= abs && abs < 0.4090877233749509) {\n        return -sgn * 0.06639489549726615 + 1.8744260009040186 * phi - sgn * 0.6158768623287225 * phi ** 2 + 0.015522814765136304 * phi ** 3;\n    } else if (0.4090877233749509 <= abs && abs < 0.5235987755982989) {\n        return -sgn * 0.14681581615727846 + 2.4641840117033467 * phi - sgn * 2.0575187819000496 * phi ** 2 + 1.19020315608481 * phi ** 3;\n    } else if (0.5235987755982989 <= abs && abs < 0.6981317007977318) {\n        return sgn * 0.07721791457421015 + 1.1805652877548842 * phi + sgn * 0.3940123976404571 * phi ** 2 - 0.3704900653862953 * phi ** 3;\n    } else if (0.6981317007977318 <= abs && abs < 0.7853981633974483) {\n        return -sgn * 0.1588736587942942 + 2.1950940927012734 * phi - sgn * 1.0591930703065233 * phi ** 2 + 0.32336443526950304 * phi ** 3;\n    } else if (0.7853981633974483 <= abs && abs < 0.8726646259971648) {\n        return sgn * 0.11028300760570171 + 1.1669913585325788 * phi + sgn * 0.24982798688740127 * phi ** 2 - 0.23220135636727493 * phi ** 3;\n    } else if (0.8726646259971648 <= abs && abs < 1.0471975511965979) {\n        return -sgn * 0.2809128662647336 + 2.5118237106750603 * phi - sgn * 1.2912363717209085 * phi ** 2 + 0.35644186834133407 * phi ** 3;\n    } else if (1.0471975511965979 <= abs && abs < 1.1617086034199458) {\n        return sgn * 1.188427789086762 - 1.6975272002562982 * phi + sgn * 2.7283976563776804 * phi ** 2 - 0.9230473816432199 * phi ** 3;\n    } else if (1.1617086034199458 <= abs && abs < 1.2217304763960306) {\n        return sgn * 4.847660398674314 - 11.147141153742991 * phi + sgn * 10.86263538662091 * phi ** 2 - 3.2570342082584616 * phi ** 3;\n    } else if (1.2217304763960306 <= abs && abs < 1.3089969389957472) {\n        return -sgn * 5.540054014819371 + 14.360238618274215 * phi - sgn * 10.01543900443557 * phi ** 2 + 2.43927792015917 * phi ** 3;\n    } else if (1.3089969389957472 <= abs && abs < 1.5707963267948966) {\n        return -sgn * 1.4869914313380834 + 5.071303412839508 * phi - sgn * 2.919215225210305 * phi ** 2 + 0.6322393733592473 * phi ** 3;\n    } else if (abs >= 1.5707963267948966) {\n        return sgn * 1.726542100316491;\n    };\n};\nconst xnSpline = (phi) => {\n    let abs = Math.abs(phi);\n    if (abs < 0.17453292519943295) {\n        return 2.589813150474736 - 0.881199067110723 * abs ** 2 + 0.19245584301046864 * abs ** 3;\n    } else if (0.17453292519943295 <= abs && abs < 0.26179938779914946) {\n        return 2.5876896126239766 + 0.03650092694544319 * abs - 1.0903339733396469 * abs ** 2 + 0.5918740922031875 * abs ** 3;\n    } else if (0.26179938779914946 <= abs && abs < 0.3490658503988659) {\n        return 2.602120301009451 - 0.1288625810457808 * abs - 0.4586919004479805 * abs ** 2 - 0.2123575731209722 * abs ** 3;\n    } else if (0.3490658503988659 <= abs && abs < 0.4090877233749509) {\n        return 2.4957847203437633 + 0.7850244165867416 * abs - 3.07678529625927 * abs ** 2 + 2.2877374593967046 * abs ** 3;\n    } else if (0.4090877233749509 <= abs && abs < 0.5235987755982989) {\n        return 2.6748422390379516 - 0.5280742793382355 * abs + 0.1330365118653692 * abs ** 2 - 0.32769326993749 * abs ** 3;\n    } else if (0.5235987755982989 <= abs && abs < 0.6981317007977318) {\n        return 2.599995480550895 - 0.09923394218390144 * abs - 0.6859882015983179 * abs ** 2 + 0.19371405671118597 * abs ** 3;\n    } else if (0.6981317007977318 <= abs && abs < 0.7853981633974483) {\n        return 2.800391842787255 - 0.9603738761277716 * abs + 0.5475038930306387 * abs ** 2 - 0.3952350356637371 * abs ** 3;\n    } else if (0.7853981633974483 <= abs && abs < 0.8726646259971648) {\n        return 3.116441132483172 - 2.1675932373066753 * abs + 2.0845833228535398 * abs ** 2 - 1.0475918068135683 * abs ** 3;\n    } else if (0.8726646259971648 <= abs && abs < 1.0471975511965979) {\n        return 2.134129230076179 + 1.2093463330965746 * abs - 1.785104378243011 * abs ** 2 + 0.4305200152298607 * abs ** 3;\n    } else if (1.0471975511965979 <= abs && abs < 1.1617086034199458) {\n        return 2.2860306849834346 + 0.7741807196924486 * abs - 1.3695518276217105 * abs ** 2 + 0.29824553013821065 * abs ** 3;\n    } else if (1.1617086034199458 <= abs && abs < 1.2217304763960306) {\n        return -1.2292088836376829 + 9.851946585261393 * abs - 9.183702328741331 * abs ** 2 + 2.54038854779215 * abs ** 3;\n    } else if (1.2217304763960306 <= abs && abs < 1.3089969389957472) {\n        return 2.4690854411526804 + 0.7706613192182941 * abs - 1.7505692101897816 * abs ** 2 + 0.5123544704020565 * abs ** 3;\n    } else if (1.3089969389957472 <= abs && abs < 1.5707963267948966) {\n        return 8.862835251215317 - 13.882733855948137 * abs + 9.44380011080222 * abs ** 2 - 2.3382682691693693 * abs ** 3;\n    } else if (abs >= 1.5707963267948966) {\n        return 1.294906575237368;\n    };\n};\n// 吴忠性《地图投影》4-2-3\n// 胡毓钜《地图投影》12-4\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953537 * phi + 0.01476138 * phi ** 3;\n    let yn = ynSpline(phi);\n    let xn = xnSpline(phi);\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.62070986487959) {\n        y = Math.sign(y) * 1.62070986487959;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                tan: '// 胡毓钜《地图投影》12-5\n// 方炳炎《不等分纬线多圆锥投影及其应用》\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.10096477407538117;\n    let lambdaN = 3.6651914291880923;\n    // 加上符号以使上下对称\n    let y0 = phi + Math.sign(phi) * 0.06683225 * phi ** 4;\n    let yn = y0 + 0.20983796245430156 * phi;\n    let xn = Math.sqrt(6.057049067368377 - yn ** 2) + 0.43948344371692494;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.tan(Math.abs(lambda) / 5)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.tan(Math.abs(lambda) / 5)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.9776756220609721) {\n        y = Math.sign(y) * 1.9776756220609721;\n    };\n    return [x, y];\n}).rotate([-120, 0, 0]);',
                sin: '// 阎大昌《以 (x/a)^n+(y/b)^n=1 为边缘经线的多圆锥投影》\nd3.geoProjection((lambda, phi) => {\n    let b = 1.11523;\n    let C = 0.11930825303967894;\n    let lambdaN = Math.PI;\n    // 加上符号与绝对值以使上下对称\n    let y0 = 0.95 * phi + Math.sign(phi) * 0.048795271 * phi ** 4;\n    let yn = y0 + 0.194675814 * phi;\n    let xn = 1.24 * Math.cbrt(10.052210101483936 - Math.abs(yn) ** 3);\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.sin(Math.abs(lambda) / 3)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.sin(Math.abs(lambda) / 3)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.7893254476343903) {\n        y = Math.sign(y) * 1.7893254476343903;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                east: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                west: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n});',
                north: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n}).rotate([-150, -120, 90]);',
                south: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lambda, phi) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 0.9953510305742277 * phi + 0.014761224628025876 * phi ** 3;\n    let yn = 1.501487749065408 * phi - 0.23845050808110835 * phi ** 3 + 0.03725714354686819 * phi ** 5;\n    let xn = Math.sqrt(6.5736602244998785 - 1.625 * yn ** 2) + 0.025898131504747363;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN;\n    let y = phi === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = phi === 0 ? xn * b * (1 - C * Math.abs(lambda)) * lambda / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 1.6262809761582284) {\n        y = Math.sign(y) * 1.6262809761582284;\n    };\n    return [x, y];\n}).rotate([105, 165, 90]).angle([90]);',
                // TODO
                // std: '',
            };

            document.getElementById('projection').value = presets.original;
            document.getElementById('preset').onchange = () => {
                document.getElementById('projection').value = presets[document.getElementById('preset').value];
                reload();
            };

            d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json').then((json) => {
                world = json;
                reload();
            });
        </script>
    </body>
</html>
