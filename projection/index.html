<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>等差分纬线多圆锥投影（伪）</title>
    </head>
    <body>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://unpkg.com/topojson@3"></script>
        <script src="https://d3js.org/d3-geo-projection.v4.min.js"></script>
        <script src="https://unpkg.com/d3-geo-polygon@1"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
        <form onsubmit="return false">
            <ul>
                <li><label>Width</label> <input type="number" id="width" value="954"></li>
                <li><label>Height</label> <input type="number" id="height" value="600"></li>
                <li><label>Projection</label> <textarea id="projection" rows="10" cols="100"></textarea></li>
                <li><label>Preset</label> <select id="preset">
                    <option value="original">等差分纬线多圆锥投影（1963 年方案）</option>
                    <option value="tan">正切差分纬线多圆锥投影（1976 年方案）</option>
                    <option value="sin">正弦差分纬线多圆锥投影（1979 年方案）</option>
                    <option value="east">系列世界地图（东半球）</option>
                    <option value="west">系列世界地图（西半球）</option>
                    <option value="north">系列世界地图（北半球）</option>
                    <option value="south">系列世界地图（南半球）</option>
                </select></li>
                <li><label>Precision</label> <input type="number" id="precision" value="0.7071067811865476" step="any"></li>
            </ul>
            <button onclick="return reload() && false">Reload</button>
        </form>
        <script>
            'use strict';

            let svg = d3.select('body').append('svg');
            let outline = { type: 'Sphere' };
            let graticule = d3.geoGraticule10();
            let world;

            // 修正曲线定向
            // https://observablehq.com/@fil/rewind
            const rewind = (() => {
                const geoRewindFeature = (feature, simple) =>
                    geoProjectSimple(feature, geoRewindStream(simple));
                const geoRewindProjection = (projection, simple) => {
                    const { stream: normalize } = geoRewindStream(simple);
                    return { stream: (s) => normalize(projection.stream(s)) };
                };
                function geoRewindStream(simple = true) {
                    const { geoContains, geoArea } = d3;

                    let ring, polygon;
                    return d3.geoTransform({
                        polygonStart() {
                            this.stream.polygonStart();
                            polygon = [];
                        },
                        lineStart() {
                            if (polygon) polygon.push((ring = []));
                            else this.stream.lineStart();
                        },
                        lineEnd() {
                            if (!polygon) this.stream.lineEnd();
                        },
                        point(x, y) {
                            if (polygon) ring.push([x, y]);
                            else this.stream.point(x, y);
                        },
                        polygonEnd() {
                            for (let [i, ring] of polygon.entries()) {
                                ring.push(ring[0].slice());
                                if (
                                    i
                                        ? // a hole must contain the first point of the polygon
                                            !geoContains(
                                                { type: 'Polygon', coordinates: [ring] },
                                                polygon[0][0]
                                            )
                                        : polygon[1]
                                        ? // the outer ring must contain the first point of its first hole (if any)
                                            !geoContains(
                                                { type: 'Polygon', coordinates: [ring] },
                                                polygon[1][0]
                                            )
                                        : // a single ring polygon must be smaller than a hemisphere (optional)
                                            simple &&
                                            geoArea({ type: 'Polygon', coordinates: [ring] }) > 2 * Math.PI
                                ) {
                                    ring.reverse();
                                };

                                this.stream.lineStart();
                                ring.pop();
                                for (const [x, y] of ring) this.stream.point(x, y);
                                this.stream.lineEnd();
                            };
                            this.stream.polygonEnd();
                            polygon = null;
                        }
                    });
                };
                const geoProjectSimple = (() => {
                    const { geoStream } = d3;

                    function projectFeatureCollection(o, stream) {
                        return { ...o, features: o.features.map((f) => projectFeature(f, stream)) };
                    };

                    function projectFeature(o, stream) {
                        return { ...o, geometry: projectGeometry(o.geometry, stream) };
                    };

                    function projectGeometryCollection(o, stream) {
                        return {
                            ...o,
                            geometries: o.geometries.map((o) => projectGeometry(o, stream))
                        };
                    };

                    function projectGeometry(o, stream) {
                        return !o
                            ? null
                            : o.type === 'GeometryCollection'
                            ? projectGeometryCollection(o, stream)
                            : o.type === 'Polygon' || o.type === 'MultiPolygon'
                            ? projectPolygons(o, stream)
                            : o;
                    };

                    function projectPolygons(o, stream) {
                        let coordinates = [];
                        let polygon, line;
                        geoStream(
                            o,
                            stream({
                                polygonStart() {
                                    coordinates.push((polygon = []));
                                },
                                polygonEnd() {},
                                lineStart() {
                                    polygon.push((line = []));
                                },
                                lineEnd() {
                                    line.push(line[0].slice());
                                },
                                point(x, y) {
                                    line.push([x, y]);
                                }
                            })
                        );
                        if (o.type === 'Polygon') coordinates = coordinates[0];
                        return { ...o, coordinates, rewind: true };
                    };

                    return function (object, projection) {
                        const stream = projection.stream;
                        let project;
                        if (!stream) throw new Error('invalid projection');
                        switch (object && object.type) {
                            case 'Feature':
                                project = projectFeature;
                                break;
                            case 'FeatureCollection':
                                project = projectFeatureCollection;
                                break;
                            default:
                                project = projectGeometry;
                                break;
                        };
                        return project(object, stream);
                    };
                })();
                // a simple duck test for projections and GeoJSON
                return function rewind(duck, simple) {
                    return duck?.stream
                        ? geoRewindProjection(duck, simple)
                        : duck?.type
                        ? geoRewindFeature(duck, simple)
                        : Array.isArray(duck)
                        ? Array.from(duck, (d) => rewind(d, simple))
                        : duck;
                };
            })();

            // 多边形，但是在圆柱投影下
            // https://observablehq.com/@fil/wgs84-resampling
            const resample = (() => {
                // by Mike Bostock -- https://github.com/d3/d3-geo-projection/issues/75
                // Takes a sparse line string that assumes Cartesian interpolation in spherical
                // coordinates and inserts interstitial points for greater accuracy when
                // rendering with D3, which assumes spherical interpolation.
                function resamplecoordinates(coordinates) {
                    var i = 0,
                            j = -1,
                            n = coordinates.length,
                            source = coordinates.slice(),
                            p0, x0, y0,
                            p1 = coordinates[0], x1 = p1[0], y1 = p1[1],
                            dx, dy, d2,
                            m2 = 10; // squared minimum angular distance
                    while (++i < n) {
                        p0 = p1, x0 = x1, y0 = y1;
                        p1 = source[i], x1 = p1[0], y1 = p1[1];
                        dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
                        coordinates[++j] = p0;
                        if (d2 > m2) for (var k = 1, m = Math.ceil(Math.sqrt(d2 / m2)); k < m; ++k) {
                            coordinates[++j] = [x0 + dx * k / m, y0 + dy * k / m];
                        };
                    };
                    coordinates[++j] = p1;
                    coordinates.length = j + 1;
                    return coordinates;
                };
                return function resample(obj) {
                    obj = JSON.parse(JSON.stringify(obj)); // deep clone urk
                    switch (obj.type) {
                        case 'FeatureCollection':
                            obj.features = obj.features.map(resample);
                            break;
                        case 'Feature':
                            obj.geometry = resample(obj.geometry);
                            break;
                        case 'MultiPolygon':
                            obj.coordinates = obj.coordinates.map(d => d.map(resamplecoordinates));
                            break;
                        case 'Polygon':
                            obj.coordinates = obj.coordinates.map(resamplecoordinates);
                            break;
                        case 'MultiLineString':
                            obj.coordinates = obj.coordinates.map(resamplecoordinates);
                            break;
                        case 'LineString':
                            obj.coordinates = resamplecoordinates(obj.coordinates);
                            break;
                    };
                    return obj;
                };
            })();

            const reload = () => {
                let projection = eval(document.getElementById('projection').value);
                let path = d3.geoPath(projection);
                svg.html(null);
                svg.attr('width', document.getElementById('width').value).attr('height', document.getElementById('height').value);
                let defs = svg.append('defs');
                projection.fitExtent([[0.5, 0.5], [svg.attr('width') - 0.5, svg.attr('height') - 0.5]], outline);
                projection.precision(document.getElementById('precision').value);
                defs.append('path').datum(outline).attr('id', 'outline').attr('d', path);
                defs.append('clipPath').attr('id', 'clip').append('use').attr('xlink:href', '#outline');
                svg.append('path').datum(graticule).attr('id', 'graticule').attr('d', path).attr('clip-path', 'url(#clip)').attr('stroke', '#808080').attr('fill', 'none');
                svg.append('path').datum(rewind(topojson.feature(world, world.objects.land))).attr('id', 'land').attr('d', path).attr('clip-path', 'url(#clip)');
                svg.append('use').attr('xlink:href', '#outline').attr('stroke', '#000000').attr('fill', 'none');
            };

            let presets = {
                original: '// 依方炳炎《不等分纬线多圆锥投影及其应用》所给正切差分纬线多圆锥投影表格推测黄赤交角取 23.44°\nlet outlineData = [[-1.5707963267948966, -1.3962634015954636, -1.3089969389957472, -1.2217304763960306, -1.1616911501274259, -1.0471975511965979, -0.8726646259971648, -0.7853981633974483, -0.6981317007977318, -0.5235987755982989, -0.40910517666747087, -0.3490658503988659, -0.26179938779914946, -0.17453292519943295, 0, 0.17453292519943295, 0.26179938779914946, 0.3490658503988659, 0.40910517666747087, 0.5235987755982989, 0.6981317007977318, 0.7853981633974483, 0.8726646259971648, 1.0471975511965979, 1.1616911501274259, 1.2217304763960306, 1.3089969389957472, 1.3962634015954636, 1.5707963267948966], [8250000, 9716500, 10369000, 11034800, 11497900, 12343200, 13482300, 13967800, 14413300, 15212800, 15664300, 15878200, 16138900, 16335500, 16500000, 16335500, 16138900, 15878200, 15664300, 15212800, 14413300, 13967800, 13482300, 12343200, 11497900, 11034800, 10369000, 9716500, 8250000], [-11000000, -10345000, -9986100, -9577200, -9247000, -8555100, -7419900, -6807200, -6163300, -4779600, -3812500, -3271700, -2456300, -1663900, 0, 1663900, 2456300, 3271700, 3812500, 4779600, 6163300, 6807200, 7419900, 8555100, 9247000, 9577200, 9986100, 10345000, 11000000]];\nlet ynSpline = numeric.spline(outlineData[0], outlineData[2]);\nlet xnSpline = numeric.spline(outlineData[0], outlineData[1]);\n// 吴忠性《地图投影》4-2-3\n// 胡毓钜《地图投影》12-4\nd3.geoProjection((lon, lat) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 6341513.8837292 * lat + 94046.46430008 * lat ** 3;\n    let yn = ynSpline.at(lat);\n    let xn = xnSpline.at(lat);\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lon)) * lon / lambdaN;\n    let y = lat === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = lat === 0 ? xn * b * (1 - C * Math.abs(lon)) * lon / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 10325730.551492194) {\n        y = Math.sign(y) * 10325730.551492194;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                tan: '// 胡毓钜《地图投影》12-5\n// 方炳炎《不等分纬线多圆锥投影及其应用》\nd3.geoProjection((lon, lat) => {\n    let b = 1.1;\n    let C = 0.10096477407538117;\n    let lambdaN = 3.6651914291880923;\n    // 加上符号以使上下对称\n    let y0 = 6371116 * lat + Math.sign(lat) * 425796.017291 * lat ** 4;\n    let yn = y0 + 1336902 * lat;\n    let xn = Math.sqrt(245862400000000 - yn ** 2) + 2800000;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.tan(Math.abs(lon) / 5)) * lon / lambdaN;\n    let y = lat === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = lat === 0 ? xn * b * (1 - C * Math.tan(Math.abs(lon) / 5)) * lon / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 12600000.798522612) {\n        y = Math.sign(y) * 12600000.798522612;\n    };\n    return [x, y];\n}).rotate([-120, 0, 0]);',
                sin: '// 阎大昌《以 (x/a)^n+(y/b)^n=1 为边缘经线的多圆锥投影》\nd3.geoProjection((lon, lat) => {\n    let b = 1.11523;\n    let C = 0.11930825303967894;\n    let lambdaN = Math.PI;\n    // 加上符号与绝对值以使上下对称\n    let y0 = 6052560.2 * lat + Math.sign(lat) * 310880.331792436 * lat ** 4;\n    let yn = y0 + 1240302.193388424 * lat;\n    let xn = 1.24 * Math.cbrt(2.599609375e+21 - Math.abs(yn) ** 3);\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.sin(Math.abs(lon) / 3)) * lon / lambdaN;\n    let y = lat === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = lat === 0 ? xn * b * (1 - C * Math.sin(Math.abs(lon) / 3)) * lon / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 11399999.988630626) {\n        y = Math.sign(y) * 11399999.988630626;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                east: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lon, lat) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 6341496.876507951 * lat + 94045.47440720971 * lat ** 3;\n    let yn = 9566152.621874606 * lat - 1519195.8472436785 * lat ** 3 + 237369.5833657487 * lat ** 5;\n    let xn = Math.sqrt(266832225000000 - 1.625 * yn ** 2) + 165000;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lon)) * lon / lambdaN;\n    let y = lat === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = lat === 0 ? xn * b * (1 - C * Math.abs(lon)) * lon / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 10361224.747697309) {\n        y = Math.sign(y) * 10361224.747697309;\n    };\n    return [x, y];\n}).rotate([-150, 0, 0]);',
                west: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lon, lat) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 6341496.876507951 * lat + 94045.47440720971 * lat ** 3;\n    let yn = 9566152.621874606 * lat - 1519195.8472436785 * lat ** 3 + 237369.5833657487 * lat ** 5;\n    let xn = Math.sqrt(266832225000000 - 1.625 * yn ** 2) + 165000;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lon)) * lon / lambdaN;\n    let y = lat === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = lat === 0 ? xn * b * (1 - C * Math.abs(lon)) * lon / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 10361224.747697309) {\n        y = Math.sign(y) * 10361224.747697309;\n    };\n    return [x, y];\n});',
                north: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lon, lat) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 6341496.876507951 * lat + 94045.47440720971 * lat ** 3;\n    let yn = 9566152.621874606 * lat - 1519195.8472436785 * lat ** 3 + 237369.5833657487 * lat ** 5;\n    let xn = Math.sqrt(266832225000000 - 1.625 * yn ** 2) + 165000;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lon)) * lon / lambdaN;\n    let y = lat === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = lat === 0 ? xn * b * (1 - C * Math.abs(lon)) * lon / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 10361224.747697309) {\n        y = Math.sign(y) * 10361224.747697309;\n    };\n    return [x, y];\n}).rotate([-150, -120, 90]);',
                south: '// 郝晓光《经纬跨越四百年》附录 1\nd3.geoProjection((lon, lat) => {\n    let b = 1.1;\n    let C = 0.028937262380344605;\n    let lambdaN = Math.PI;\n    let y0 = 6341496.876507951 * lat + 94045.47440720971 * lat ** 3;\n    let yn = 9566152.621874606 * lat - 1519195.8472436785 * lat ** 3 + 237369.5833657487 * lat ** 5;\n    let xn = Math.sqrt(266832225000000 - 1.625 * yn ** 2) + 165000;\n    let rho = (xn ** 2 + (yn - y0) ** 2) / (2 * (yn - y0));\n    let deltaPhiN = Math.asin(xn / rho);\n    // 加上绝对值以使左右对称\n    let deltaPhi = deltaPhiN * b * (1 - C * Math.abs(lon)) * lon / lambdaN;\n    let y = lat === 0 ? 0 : y0 + rho * (1 - Math.cos(deltaPhi));\n    let x = lat === 0 ? xn * b * (1 - C * Math.abs(lon)) * lon / lambdaN : rho * Math.sin(deltaPhi);\n    // 裁切一下\n    // 不过这样的实现还不够完美\n    if (Math.abs(y) > 10361224.747697309) {\n        y = Math.sign(y) * 10361224.747697309;\n    };\n    return [x, y];\n}).rotate([105, 165, 90]).angle([90]);',
                // TODO
                // std: '',
            };

            document.getElementById('projection').value = presets.original;
            document.getElementById('preset').onchange = () => {
                document.getElementById('projection').value = presets[document.getElementById('preset').value];
                reload();
            };

            d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json').then((json) => {
                world = json;
                reload();
            });
        </script>
    </body>
</html>
